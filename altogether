from spike import PrimeHub, LightMatrix, Button, StatusLight, ForceSensor, MotionSensor, Speaker, ColorSensor, App, DistanceSensor, Motor, MotorPair
from spike.control import wait_for_seconds, wait_until, Timer
from math import *
import time

# establish port connections
hub = PrimeHub()
motors = MotorPair('C', 'D')
grab_arm = Motor('E')
light_a = ColorSensor('A')
light_b = ColorSensor('B')
distance = DistanceSensor('F')

# speed configuration
speed = 60
maneuvering_speed = 50
high_maneuvering_speed = 20

# other configuration
rgb_margin = 0.05 * 1024 # (how much rgb values may differ in order for it to be interpreted as grayscale)

class LineGuidance:
    # reflection calibration
    min_light = 20 # (black)
    max_light = 98 # (white)

    def initialize(self):
        # calibrate lights

        # max_light / white
        hub.left_button.wait_until_pressed()
        self.max_light = light_a.get_reflected_light()
        hub.speaker.beep(65, 0.5)

        # min_light / black
        hub.left_button.wait_until_released()
        self.min_light = light_a.get_reflected_light()
        hub.speaker.beep(70, 0.5)

    instructions = []

    def drive(self):
        print("drive")
        self.instructions.append(("drive",))

    def drive_and_take_crossing(self, crossing_target):
        print("drive and take crossing " + str(crossing_target))
        self.instructions.append(("drive_and_take_crossing", str(crossing_target)))

    def switch_to_lane(self, new_lane): # new_lane = 'A' or 'B'
        print("switching to lane " + new_lane)
        self.instructions.append(("switch_to_lane", new_lane))

    def run(self):
        self.crossings_left = -1
        for instruction in self.instructions:
            self.execute_instruction(instruction)

    light_pr = light_b
    light_sc = light_a
    invert_steering = True

    crossings_left = -1
    lastly_crossing = False

    sc_on_track_start = -1

    def execute_instruction(self, instruction):
        print("executing instruction: " + str(instruction))

        # ----- drive -----
        instruction_name = instruction[0]
        print("instruction name: " + str(instruction_name))
        length = len(instruction)
        print("length: " + str(length))
        if instruction_name == "drive" and length == 1:
            print("driving...")
            while True:

                light_pr_percent = (self.light_pr.get_reflected_light() - self.min_light) / (self.max_light - self.min_light)
                light_sc_percent = (self.light_sc.get_reflected_light() - self.min_light) / (self.max_light - self.min_light)

                currently_crossing = self.light_sc.get_color() == "black"
                if currently_crossing:
                    hub.status_light.on("green")
                else:
                    hub.status_light.on("blue")
                if self.lastly_crossing != currently_crossing:
                    if currently_crossing:
                        motors.stop()
                        hub.speaker.start_beep(60)
                        self.crossings_left = self.crossings_left - 1
                        if self.crossings_left == 0:

                            hub.speaker.beep(80, 1)

                            former_light_pr = self.light_pr
                            former_light_sc = self.light_sc
                            self.light_pr = former_light_sc
                            self.light_sc = former_light_pr
                            self.invert_steering = not self.invert_steering

                            while True:
                                motors.start_tank_at_power(int(high_maneuvering_speed/2), int(high_maneuvering_speed*2))
                                former_light_sc_percent = (former_light_sc.get_reflected_light() - self.min_light) / (self.max_light - self.min_light)
                                if former_light_sc_percent > 0.8:
                                    break
                    else:
                        hub.speaker.stop()

                    self.lastly_crossing = currently_crossing

                steering = (light_pr_percent - 0.5) * 100
                dynamic_speed = speed - ( abs(steering)/100 * (speed - maneuvering_speed) )
                if self.invert_steering:
                    steering = -steering
                motors.start_at_power(int(dynamic_speed), int(steering))

        # ----- drive and take crossing -----
        if instruction_name == "drive_and_take_crossing" and length == 2:
            self.crossings_left = int(instruction[1])
            print("driving and taking crossing " + str(self.crossings_left) + "...")
            self.execute_instruction(("drive",))

        # ----- switch to lane -----
        if instruction_name == "switch_to_lane" and length == 2:
            new_lane = instruction[1]
            old_light_pr = self.light_pr
            old_light_sc = self.light_sc
            self.light_pr = light_a
            self.light_sc = light_b
            if new_lane == "B":
                self.light_pr = light_b
                self.light_sc = light_a

            start_time = time.time()
            while True:
                if new_lane == "A":
                    motors.start_tank_at_power(maneuvering_speed, maneuvering_speed * 0.05)
                else:
                    motors.start_tank_at_power(maneuvering_speed * 0.05, maneuvering_speed)
                if self.light_pr.get_color() == "black":
                    break
            duration = time.time() - start_time()
            new_time = duration * 0.8
            start_time = time.time()
            while True:
                if new_lane == "A":
                    motors.start_tank_at_power(maneuvering_speed, maneuvering_speed * 0.05)
                else:
                    motors.start_tank_at_power(maneuvering_speed * 0.05, maneuvering_speed)
                if time.time() - start_time >= new_time:
                    break
            print("realigned")

class GrabArm:
    def initialize(self):
        grab_arm.run_to_position(0)
        print('test')
        
    def move(self, position):
        grab_arm.run_to_position(position)


GrabArm.initialize(GrabArm)
hub.right_button.wait_until_pressed()
GrabArm.move(GrabArm, 100)

guidance = LineGuidance()
guidance.initialize()

# wait for start
hub.right_button.wait_until_pressed()
hub.speaker.beep(80, 0.7)

motors.move(10)

# programming space

#guidance.drive()
#guidance.drive_and_take_crossing(1)
#guidance.switch_to_lane("B")
#guidance.drive()

#guidance.run()

#A02:

hub.status_light.on('yellow')

motor_pair.move_tank(20, 'cm', left_speed=50, right_speed=50) # Geradeaus fahren # motor_pair.move(15, 'cm')
hub.status_light.on('red') # Dient zur Kontrolle
motor_pair.move_tank(0.5, 'rotations', left_speed=0, right_speed=50) # Linkskurve zur Kiste # ggf. mit Ultraschallsensor
hub.status_light.on('blue') # Dient zur Kontrolle
# Greifarm senken auf mittlere Höhe
motor_pair.move_tank(25, 'cm', left_speed=75, right_speed=75) # Geradeaus fahren
hub.status_light.on('green') # Dient zur Kontrolle

#A14:

greifarm.run_to_position(190)
# print("check")
motor_pair.move_tank(15, 'cm', 50, 50) # Linien-Folger
greifarm.run_to_position(210)
motor_pair.move_tank(15, 'cm', 50, 50) # Linien-Folger
greifarm.run_to_position(190)
motor_pair.move_tank(15, 'cm', -50, -50) # Linien-Folger


hub.status_light.off()

#A08

#an rechtem Sensor nach rechts um die Ecke fahren:

#A09

#Greifarm nach oben:
#greifarm.run_for_rotations(0.25)

#Sensor zu linkem Sensor wechseln:

#Linie mit linkem Sensor folgen, bis rechter Sensor schwarz erkennt:

#Schienen schließen:
motor_pair.move_tank(10,'cm',left_speed=0,right_speed=75)
motor_pair.move_tank(4,'cm',left_speed=100,right_speed=100)
greifarm.run_for_rotations(-0.25)
motor_pair.move_tank(-4,'cm',left_speed=100,right_speed=100)
greifarm.run_for_rotations(0.25)
motor_pair.move_tank(10,'cm',left_speed=0,right_speed=-75)

#Linie rückwärts it linkem Sensor folgen, bis rechter Sensor schwarz erkennt:

#Bahn nach vorne schieben:
#greifarm.run_for_rotations(0.25)
    #Linie vorwärts folgen, bis Sensor rechts schwarz erkennt:

#zurückholen

hub.left_button.wait_until_pressed()

#A03:

def geradeaus(nullpunkt):
    #greifarm hoch:
    greifarm.run_to_position(nullpunkt)

    #Linie mit linkem Sensor folgen, wenn Rechtskurve anfängt, Richtung beibehalten:

    #geradeaus zu Flugzeug fahren:
    motor.move_tank(1.3,'rotations',left_speed=75,right_speed=75)

    #Klappe schließen:
    greifarm.start(speed=-75)
    motor.move_tank(-0.5,'rotations',left_speed=25,right_speed=25)
    greifarm.stop()
    greifarm.run_for_degrees(10,speed=50)
    motor.move_tank(-0.8,'rotations',left_speed=75,right_speed=75)

    
def linie_nehmen(nullpunkt):
    #greifarm hoch:
    greifarm.run_to_position(nullpunkt)

    #Linie mit rechtem Sensor folgen, Linkskurve nehmen, warten bis Sensor weiß erkennt:

    #um 90° nach links drehen:
    motor.move_tank(7,'cm',left_speed=0,right_speed=75)

    #greifarm runter:
    greifarm.run_to_position(nullpunkt - 50)

    #greifarm hoch:
    greifarm.run_to_position(nullpunkt)

    #um 90° nach rechts drehen:
    motor.move_tank(7,'cm',left_speed=0,right_speed=-75)

geradeaus(100)

A05:

A06:
